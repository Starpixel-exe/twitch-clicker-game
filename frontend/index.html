<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Feed Me! ‚Äî Shared Leaderboard</title>
  <style>
    :root {
      --bg: #f7f7fb;
      --card: #ffffff;
      --text: #222;
      --muted: #6b7280;
      --accent: #e74c3c; /* red button */
      --shadow: 0 10px 24px rgba(0,0,0,0.08);
      --radius: 16px;
    }
    html, body {
      margin: 0; padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    }
    .wrap {
      max-width: 760px;
      margin: 40px auto;
      padding: 0 16px;
      text-align: center;
    }
    h1 { margin: 0 0 18px; font-weight: 800; letter-spacing: .2px; }
    #character-container {
      position: relative;
      width: 340px; height: 340px;
      margin: 8px auto 18px;
    }
    #character-container img {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: contain;
      transition: opacity .18s ease-in-out;
    }
    /* Button */
    #feedBtn {
      display: inline-flex; align-items: center; gap: 10px;
      padding: 14px 22px; border-radius: 12px; border: none;
      background: var(--accent); color: #fff; font-weight: 800;
      letter-spacing: .2px; cursor: pointer; box-shadow: var(--shadow);
      user-select: none; transform: translateZ(0);
    }
    #feedBtn:active { transform: scale(.97); }
    .bone { font-size: 18px; }
    /* Bounce */
    .bounce { animation: bounce .6s ease; }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      30% { transform: translateY(-14px); }
      60% { transform: translateY(-6px); }
    }
    /* Scores row */
    #scoresRow {
      display: flex; gap: 12px; justify-content: center; margin-top: 12px;
    }
    .scoreCard {
      background: var(--card); box-shadow: var(--shadow);
      border-radius: 14px; padding: 10px 14px; min-width: 120px;
    }
    .scoreCard .label {
      font-size: 12px; letter-spacing: .06em; text-transform: uppercase;
      color: var(--muted); margin-bottom: 2px;
    }
    .scoreCard .value { font-size: 22px; font-weight: 800; }
    /* Leaderboard card */
    .card {
      background: var(--card); box-shadow: var(--shadow);
      border-radius: var(--radius); padding: 14px; margin: 22px auto 0; text-align: left;
    }
    .card h2 { margin: 0 0 8px; text-align: center; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 10px 8px; }
    th { text-align: left; font-weight: 700; color: var(--muted); }
    tr + tr td { border-top: 1px solid #eee; }
    .right { text-align: right; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Feed Me!</h1>

    <div id="character-container">
      <!-- Start with idle frame (frame2) visible -->
      <img id="frame1" src="./images/frame1.png" alt="character frame 1" style="opacity:0;">
      <img id="frame2" src="./images/frame2.png" alt="character frame 2" style="opacity:1;">
    </div>

    <button id="feedBtn"><span class="bone">üçñ</span> Feed Me!</button>

    <!-- Current vs Best scores -->
    <div id="scoresRow">
      <div class="scoreCard">
        <div class="label">Current</div>
        <div class="value" id="currentScoreVal">0</div>
      </div>
      <div class="scoreCard">
        <div class="label">Best</div>
        <div class="value" id="bestScoreVal">0</div>
      </div>
    </div>

    <div class="card">
      <h2>Leaderboard</h2>
      <table>
        <thead><tr><th>Player</th><th class="right">Score</th></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>

  <script>
    // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    // 1) Set this to YOUR backend URL (no trailing slash)
    const API_BASE_URL = 'https://feed-me-backend-eq0n.onrender.com';
    // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

    // State
    let currentParticipantId = null;
    let clickCount = 0;               // for multiplier (every 50)
    let currentSessionScore = 0;      // resets after idle
    let highestScore = 0;             // personal best (persistent while tab open)
    let postedScore = 0;              // what we've already posted to server
    let idleTimerId = null;
    const IDLE_MS = 5000;

    // DOM refs
    const btn = document.getElementById('feedBtn');
    const container = document.getElementById('character-container');
    const frame1 = document.getElementById('frame1'); // "fed" flash
    const frame2 = document.getElementById('frame2'); // idle frame
    const tbody = document.getElementById('tbody');

    // API helpers
    async function fetchLeaderboard() {
      const r = await fetch(`${API_BASE_URL}/leaderboard`);
      if (!r.ok) throw new Error('Failed to fetch leaderboard');
      return r.json(); // array of {id,name,score}
    }
    async function addParticipant(name) {
      const r = await fetch(`${API_BASE_URL}/player`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      if (!r.ok) throw new Error('Failed to add participant');
      return r.json();
    }
    async function incrementScoreBy(id, inc) {
      const r = await fetch(`${API_BASE_URL}/score`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id, inc })
      });
      if (!r.ok) throw new Error('Failed to increment score');
      return r.json();
    }

    // UI helpers
    function updateScoreUI() {
      document.getElementById('currentScoreVal').textContent = currentSessionScore;
      document.getElementById('bestScoreVal').textContent = highestScore;
    }
    async function renderLeaderboard() {
      const data = await fetchLeaderboard();
      tbody.innerHTML = '';
      data.slice(0, 50).forEach((p, idx) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${idx + 1}. ${p.name}</td><td class="right">${p.score}</td>`;
        tbody.appendChild(tr);
      });
    }
    function armIdleTimer() {
      if (idleTimerId) clearTimeout(idleTimerId);
      idleTimerId = setTimeout(() => {
        // reset ONLY current run/multiplier; Best & leaderboard remain
        clickCount = 0;
        currentSessionScore = 0;
        updateScoreUI();
        // ensure idle frame is visible
        frame1.style.opacity = '0';
        frame2.style.opacity = '1';
      }, IDLE_MS);
    }

    // Init + click logic
    async function initGame(username) {
      // Find or create participant
      const board = await fetchLeaderboard();
      const existing = board.find(p => p.name.toLowerCase() === username.toLowerCase());
      if (existing) {
        currentParticipantId = existing.id;
        postedScore = Number(existing.score) || 0;
        highestScore = postedScore;
      } else {
        const p = await addParticipant(username);
        currentParticipantId = p.id;
        postedScore = 0;
        highestScore = 0;
      }
      currentSessionScore = 0;
      clickCount = 0;
      updateScoreUI();
      renderLeaderboard();

      // Click animation + scoring
      btn.addEventListener('click', async () => {
        // 1) Visuals: bounce + flash frame1 then back to frame2
        container.classList.add('bounce');
        btn.classList.add('bounce');
        frame1.style.opacity = '1';
        frame2.style.opacity = '0';
        setTimeout(() => {
          container.classList.remove('bounce');
          btn.classList.remove('bounce');
          frame1.style.opacity = '0';
          frame2.style.opacity = '1';
        }, 600); // keep in sync with @keyframes bounce

        // 2) Scoring with multiplier
        clickCount += 1;
        const multiplier = Math.floor(clickCount / 50) + 1;
        currentSessionScore += multiplier;

        // If we set a new best, post only the delta beyond the server score
        if (currentSessionScore > highestScore) {
          highestScore = currentSessionScore;
          const delta = highestScore - postedScore;
          if (delta > 0) {
            try {
              await incrementScoreBy(currentParticipantId, delta);
              postedScore += delta;
              renderLeaderboard();
            } catch (err) {
              console.error('Failed to post score delta:', err);
            }
          }
        }

        updateScoreUI();
        armIdleTimer();
      });

      // Start idle timer on load
      armIdleTimer();
    }

    // Prompt for (or recall) username
    (async function bootstrap() {
      let name = localStorage.getItem('feed_me_username') || '';
      if (!name) {
        name = (prompt('Enter a display name:') || '').trim();
        if (!name) return; // user cancelled
        localStorage.setItem('feed_me_username', name);
      }
      try {
        await initGame(name);
      } catch (e) {
        console.error(e);
        alert('Failed to load the game. Check the API_BASE_URL and try again.');
      }
    })();
  </script>
</body>
</html>
